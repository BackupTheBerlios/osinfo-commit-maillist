From lamikae at mail.berlios.de  Fri Aug 29 17:10:21 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Fri, 29 Aug 2008 17:10:21 +0200
Subject: [Osinfo-commit] r720 - trunk/osinfo/modules
Message-ID: <200808291510.m7TFALAd002234@sheep.berlios.de>

Author: lamikae
Date: 2008-08-29 17:10:21 +0200 (Fri, 29 Aug 2008)
New Revision: 720

Modified:
   trunk/osinfo/modules/hdd
Log:
fixed some indentation

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2007-12-30 15:25:04 UTC (rev 719)
+++ trunk/osinfo/modules/hdd	2008-08-29 15:10:21 UTC (rev 720)
@@ -543,98 +543,98 @@
 #  (1) drive device
 #
 scan_hdd_partitions() {
-        local dev_scan="${1}" part_free=0
-        partitions_on_drive="$(grep ^${dev_scan} ${fdisk_info} | wc -l)"
-        local ID=$hdd_pt_ID
-        #local swap_color="${tcYELLOW}"
-        # marking partitions in different colours would be great, but
-        # the 'column' tool does not allow that. we should rewrite the
-        # column function.
+  local dev_scan="${1}" part_free=0
+  partitions_on_drive="$(grep ^${dev_scan} ${fdisk_info} | wc -l)"
+  local ID=$hdd_pt_ID
+  #local swap_color="${tcYELLOW}"
+  # marking partitions in different colours would be great, but
+  # the 'column' tool does not allow that. we should rewrite the
+  # column function.
 
-        #TODO for version 0.5 or so
-        #hdd_fs_ID=[83] [7] [82] ... #which tells the FS type
-        #hdd_fs_allocated=[1292372032] [28402202] [10284942]
+  #TODO for version 0.5 or so
+  #hdd_fs_ID=[83] [7] [82] ... #which tells the FS type
+  #hdd_fs_allocated=[1292372032] [28402202] [10284942]
 
 
-        # loop all partitions detected by fdisk
-        for PARTNR in $(seq 1 1 $partitions_on_drive); do
+  # loop all partitions detected by fdisk
+  for PARTNR in $(seq 1 1 $partitions_on_drive); do
 
-                ((ID++)) # increase the array number
+    ((ID++)) # increase the array number
 
-                # get the partition node
-                hdd_pt_node[$ID]="$(grep ^${dev_scan} ${fdisk_info} | \
-                        awk {'print $1'} | sed -n "${PARTNR}{p;q;}" )"
+    # get the partition node
+    hdd_pt_node[$ID]="$(grep ^${dev_scan} ${fdisk_info} | \
+      awk {'print $1'} | sed -n "${PARTNR}{p;q;}" )"
 
 
-                # get the partition size in 1 kB blocks
-                hdd_pt_blocks[$ID]="$(fdisk -s ${hdd_pt_node[$ID]})"
+    # get the partition size in 1 kB blocks
+    hdd_pt_blocks[$ID]="$(fdisk -s ${hdd_pt_node[$ID]})"
 
 
-                # detect the filesystem
-                #
-                # fdisk uses spaces, not tabs for indentation.
-                # awk's $NF does not work, as the filesystem name may have spaces.
-                # awk is looped from field 6 onward. while the field 6 is the
-                # FS type integer, it has to be included when fdisk adds a '*'
-                # character to denote bootable partitions. the numbers are removed
-                # from the beginning of string with sed.
-                hdd_pt_fs[$ID]="$(grep ^${hdd_pt_node[$ID]} ${fdisk_info} | \
-                                  awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
-                                  sed 's/^[0-9 ]*//')"
+    # detect the filesystem
+    #
+    # fdisk uses spaces, not tabs for indentation.
+    # awk's $NF does not work, as the filesystem name may have spaces.
+    # awk is looped from field 6 onward. while the field 6 is the
+    # FS type integer, it has to be included when fdisk adds a '*'
+    # character to denote bootable partitions. the numbers are removed
+    # from the beginning of string with sed.
+    hdd_pt_fs[$ID]="$(grep ^${hdd_pt_node[$ID]} ${fdisk_info} | \
+      awk '{for (i=6; i<=NF; i++) printf("%s ",$i);printf ("\n")}' | \
+      sed 's/^[0-9 ]*//')"
 
 
-                # if partition is mounted (=is in mtab)
-                #
-                # FIXME: submounted (=system for automounting usb sticks) partitions
-                # may be considered unmounted, while they are not!
+    # if partition is mounted (=is in mtab)
+    #
+    # FIXME: submounted (=system for automounting usb sticks) partitions
+    # may be considered unmounted, while they are not!
 
-                # the partition size is calculated from the value given by df,
-                # and the float division is computed by bc.
-                if [ "$(df -Plk | grep ${hdd_pt_node[$ID]})" ]; then
+    # the partition size is calculated from the value given by df,
+    # and the float division is computed by bc.
+    if [ "$(df -Plk | grep ${hdd_pt_node[$ID]})" ]; then
 
-                        # locate the mountpoint
-                        hdd_pt_mp[$ID]="$(df -PT ${hdd_pt_node[$ID]} | \
-                                grep ^${hdd_pt_node[$ID]} | awk {'print $NF'})"
+      # locate the mountpoint
+      hdd_pt_mp[$ID]="$(df -PT ${hdd_pt_node[$ID]} | \
+        grep ^${hdd_pt_node[$ID]} | awk {'print $NF'})"
 
-                        # get the partition capacity, used and free space in 1 kB blocks
-                        local df_output="$(df -Plk | grep ${hdd_pt_node[$ID]})"
-                        hdd_pt_capacity[$ID]="$(awk {'print $2'} <<< "$df_output")"
-                        hdd_pt_used[$ID]="$(awk {'print $3'} <<< "$df_output")"
-                        hdd_pt_free[$ID]="$(awk {'print $4'} <<< "$df_output")"
-                        hdd_pt_used_pc[$ID]="$(awk {'print $5'} <<< "$df_output")"
+      # get the partition capacity, used and free space in 1 kB blocks
+      local df_output="$(df -Plk | grep ${hdd_pt_node[$ID]})"
+      hdd_pt_capacity[$ID]="$(awk {'print $2'} <<< "$df_output")"
+      hdd_pt_used[$ID]="$(awk {'print $3'} <<< "$df_output")"
+      hdd_pt_free[$ID]="$(awk {'print $4'} <<< "$df_output")"
+      hdd_pt_used_pc[$ID]="$(awk {'print $5'} <<< "$df_output")"
 
-                        # calculate the space allocated by the filesystem
-                        hdd_pt_fs_size[$ID]="$(bc -s <<< scale=1\;" \
-                                "${hdd_pt_free[$ID]}-${hdd_pt_capacity[$ID]})"
+      # calculate the space allocated by the filesystem
+      hdd_pt_fs_size[$ID]="$(bc -s <<< scale=1\;" \
+        "${hdd_pt_free[$ID]}-${hdd_pt_capacity[$ID]})"
 
-                        # calculate the percentages of free and used space
-                        hdd_pt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
-                                "${hdd_pt_free[$ID]}/${hdd_pt_capacity[$ID]}*100)%"
+      # calculate the percentages of free and used space
+      hdd_pt_free_pc[$ID]="$(bc -s <<< scale=1\;" \
+        "${hdd_pt_free[$ID]}/${hdd_pt_capacity[$ID]}*100)%"
 
-                else # unmounted
+    else # unmounted
 
-                        # it might be swap..
-                        if [ "$(swapon -s | grep ${hdd_pt_node[$ID]})" ]; then
-                        # mark 'swap' as mountpoint for swap partitions, if they're in use
-                                #hdd_pt_mp[$ID]="${swap_color}swap${tSTD}"
-                                hdd_pt_mp[$ID]="swap"
-                                hdd_pt_used[$ID]="$(swapon -s | \
-                                        grep ^${hdd_pt_node[$ID]} | awk {'print $4'})"
+      # it might be swap..
+      if [ "$(swapon -s | grep ${hdd_pt_node[$ID]})" ]; then
+        # mark 'swap' as mountpoint for swap partitions, if they're in use
+        #hdd_pt_mp[$ID]="${swap_color}swap${tSTD}"
+        hdd_pt_mp[$ID]="swap"
+        hdd_pt_used[$ID]="$(swapon -s | \
+          grep ^${hdd_pt_node[$ID]} | awk {'print $4'})"
 
-                        else
-                                hdd_pt_mp[$ID]="-"
-                                hdd_pt_used[$ID]="n/a"
-                        fi
+      else
+        hdd_pt_mp[$ID]="-"
+        hdd_pt_used[$ID]="n/a"
+      fi
 
-                        # define the rest to empty values.
-                        hdd_pt_capacity[$ID]=""
-                        hdd_pt_free[$ID]=""
-                        hdd_pt_used_pc[$ID]=""
-                        hdd_pt_fs_size[$ID]=""
+      # define the rest to empty values.
+      hdd_pt_capacity[$ID]=""
+      hdd_pt_free[$ID]=""
+      hdd_pt_used_pc[$ID]=""
+      hdd_pt_fs_size[$ID]=""
 
-                fi
+    fi
 
-        done
+  done
 }
 
 



From lamikae at mail.berlios.de  Fri Aug 29 17:26:56 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Fri, 29 Aug 2008 17:26:56 +0200
Subject: [Osinfo-commit] r721 - trunk/osinfo/modules
Message-ID: <200808291526.m7TFQuO8003452@sheep.berlios.de>

Author: lamikae
Date: 2008-08-29 17:26:56 +0200 (Fri, 29 Aug 2008)
New Revision: 721

Modified:
   trunk/osinfo/modules/hdd
Log:
fixed a regexp bug that affected systems with over 9 partitions

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-29 15:10:21 UTC (rev 720)
+++ trunk/osinfo/modules/hdd	2008-08-29 15:26:56 UTC (rev 721)
@@ -585,19 +585,20 @@
 
     # if partition is mounted (=is in mtab)
     #
-    # FIXME: submounted (=system for automounting usb sticks) partitions
+    # NOTE: submounted (=system for automounting usb sticks) partitions
     # may be considered unmounted, while they are not!
+    # Submount, on the other hand, is deprecated in 2008..
 
     # the partition size is calculated from the value given by df,
     # and the float division is computed by bc.
-    if [ "$(df -Plk | grep ${hdd_pt_node[$ID]})" ]; then
+    if [ "$(df -Plk | grep ^${hdd_pt_node[$ID]}\ )" ]; then
 
       # locate the mountpoint
       hdd_pt_mp[$ID]="$(df -PT ${hdd_pt_node[$ID]} | \
-        grep ^${hdd_pt_node[$ID]} | awk {'print $NF'})"
+        grep ^${hdd_pt_node[$ID]}\  | awk {'print $NF'})"
 
       # get the partition capacity, used and free space in 1 kB blocks
-      local df_output="$(df -Plk | grep ${hdd_pt_node[$ID]})"
+      local df_output="$(df -Plk | grep ^${hdd_pt_node[$ID]}\ )"
       hdd_pt_capacity[$ID]="$(awk {'print $2'} <<< "$df_output")"
       hdd_pt_used[$ID]="$(awk {'print $3'} <<< "$df_output")"
       hdd_pt_free[$ID]="$(awk {'print $4'} <<< "$df_output")"



From lamikae at mail.berlios.de  Fri Aug 29 17:30:51 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Fri, 29 Aug 2008 17:30:51 +0200
Subject: [Osinfo-commit] r722 - trunk/osinfo/modules
Message-ID: <200808291530.m7TFUpDq003882@sheep.berlios.de>

Author: lamikae
Date: 2008-08-29 17:30:51 +0200 (Fri, 29 Aug 2008)
New Revision: 722

Modified:
   trunk/osinfo/modules/hdd
Log:
fixed indentation

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-29 15:26:56 UTC (rev 721)
+++ trunk/osinfo/modules/hdd	2008-08-29 15:30:51 UTC (rev 722)
@@ -160,210 +160,210 @@
   # if the drive type is unknown, let's get it out of the way first..
   if [ "$hdd_type" == "unknown" ]; then
 
-          add_header  "${drvdev}"
-          add_attribute "Drive type"
-          add_values    "unknown"
-          add_footer
+    add_header  "${drvdev}"
+    add_attribute "Drive type"
+    add_values    "unknown"
+    add_footer
 
-          break;
+    break;
   fi
-  
+
   case "$output_mode" in
-          'stdout')	# standard output
+    'stdout')	# standard output
 
-                  # HDD DEVICE NODE
-                  add_header  "\n${drvdev}"
+      # HDD DEVICE NODE
+      add_header  "\n${drvdev}"
 
-                  # HDD TYPE and model name
-                  add_attribute "$hdd_type"
-                  add_values  "$(echo $hdd_vendor $hdd_model | sed 's/^ *//')"
+      # HDD TYPE and model name
+      add_attribute "$hdd_type"
+      add_values  "$(echo $hdd_vendor $hdd_model | sed 's/^ *//')"
 
-                  # bus configuration; verbose
-                  if [ $isverbose -ge 1 ]; then
-                          add_attribute 'Bus configuration'
-                          # case by the last letter in $drvdev
-                          case ${drvdev: -1:1} in
-                                  'a')
-                                          add_values 'primary master'
-                                          ;;
-                                  'b')
-                                          add_values 'primary slave'
-                                          ;;
-                                  'c')
-                                          add_values 'secondary master'
-                                          ;;
-                                  'd')
-                                          add_values 'secondary slave'
-                                          ;;
-                                  *)
-                                          add_values 'unknown'
-                                          ;;
-                          esac
-                  fi
+      # bus configuration; verbose
+      if [ $isverbose -ge 1 ]; then
+        add_attribute 'Bus configuration'
+        # case by the last letter in $drvdev
+        case ${drvdev: -1:1} in
+          'a')
+            add_values 'primary master'
+            ;;
+          'b')
+            add_values 'primary slave'
+            ;;
+          'c')
+            add_values 'secondary master'
+            ;;
+          'd')
+            add_values 'secondary slave'
+            ;;
+          *)
+            add_values 'unknown'
+            ;;
+        esac
+      fi
 
 
-                  # HDD REPORTED CAPACITY
-                  add_attribute 'Capacity (reported)'
-                  add_values  "$hdd_capacity_label"
+      # HDD REPORTED CAPACITY
+      add_attribute 'Capacity (reported)'
+      add_values  "$hdd_capacity_label"
 
-                  # verbose
-                  if [ $isverbose -ge 1 ]; then
+      # verbose
+      if [ $isverbose -ge 1 ]; then
 
-                          # HDD ACTUAL CAPACITY (verbose)
-                          add_attribute 'Capacity (actual)'
-                          add_values    "$(hdd_human_readable $hdd_capacity)"
+        # HDD ACTUAL CAPACITY (verbose)
+        add_attribute 'Capacity (actual)'
+        add_values    "$(hdd_human_readable $hdd_capacity)"
 
-                          # SERIAL NUMBER
-                          add_attribute 'Serial number'
-                          add_values    "$hdd_serial"
-                  fi
+        # SERIAL NUMBER
+        add_attribute 'Serial number'
+        add_values    "$hdd_serial"
+      fi
 
-                  # DMA
-                  add_attribute 'DMA'
-                          # if DMA is off, print it in red
-                          if [ "$(grep -i off <<< $hdd_dma)" ]; then
-                                  add_values  "${tcRED}$hdd_dma${tSTD}"
-                          elif [ "$(grep -i on <<< $hdd_dma)" ]; then
-                                  #add_values  "$hdd_dma"
-                                  add_values  "${tcGREEN}$hdd_dma${tSTD}"
-                          else
-                                  add_values  "${tcRED}n/a${tSTD}"
-                          fi
+      # DMA
+      add_attribute 'DMA'
+        # if DMA is off, print it in red
+        if [ "$(grep -i off <<< $hdd_dma)" ]; then
+                add_values  "${tcRED}$hdd_dma${tSTD}"
+        elif [ "$(grep -i on <<< $hdd_dma)" ]; then
+                #add_values  "$hdd_dma"
+                add_values  "${tcGREEN}$hdd_dma${tSTD}"
+        else
+                add_values  "${tcRED}n/a${tSTD}"
+        fi
 
-                  # ACTIVITY STATE; verbose
-                  if [ $isverbose -ge 1 ]; then
-                          add_attribute 'State'
-                          add_values "$hdd_state"
-                  fi
+      # ACTIVITY STATE; verbose
+      if [ $isverbose -ge 1 ]; then
+        add_attribute 'State'
+        add_values "$hdd_state"
+      fi
 
-                  # ATA standard; more verbose
-                  if [ $isverbose -ge 2 ]; then
-                          add_attribute   'ATA Standard'
-                          add_values      "$hdd_ata_standard"
+      # ATA standard; more verbose
+      if [ $isverbose -ge 2 ]; then
+        add_attribute   'ATA Standard'
+        add_values      "$hdd_ata_standard"
 
-                          add_attribute 'Driver'
-                          add_values    "$hdd_driver"
+        add_attribute 'Driver'
+        add_values    "$hdd_driver"
 
-                          add_attribute 'Geometry'
-                          add_values    "$hdd_geometry"
-                  fi
+        add_attribute 'Geometry'
+        add_values    "$hdd_geometry"
+      fi
 
 
-                  # SMART capability; more verbose
-                  if [ $isverbose -ge 2 ]; then
-                          # SMART capability
-                          add_attribute   'S.M.A.R.T.'
-                          add_values      "$hdd_smart"
-                  fi
+      # SMART capability; more verbose
+      if [ $isverbose -ge 2 ]; then
+        # SMART capability
+        add_attribute   'S.M.A.R.T.'
+        add_values      "$hdd_smart"
+      fi
 
-                  # S.M.A.R.T DATA
-                  # TODO: use add_subheader
-                  if [ "$(type -p smartctl)" ]; then
+      # S.M.A.R.T DATA
+      # TODO: use add_subheader
+      if [ "$(type -p smartctl)" ]; then
 
-                          # TEMPERATURE
-                          add_attribute   'Temperature'
-                          add_values  "$hdd_tempC"
-                                  [ "$hdd_tempC" ]
+        # TEMPERATURE
+        add_attribute   'Temperature'
+        add_values  "$hdd_tempC"
+                [ "$hdd_tempC" ]
 
-                          # verbose
-                          if [ $isverbose -ge 1 ]; then
+        # verbose
+        if [ $isverbose -ge 1 ]; then
 
-                                  # LIFETIME
-                                  add_attribute   'Lifetime'
-                                  add_values      "$hdd_lifetime"
+          # LIFETIME
+          add_attribute   'Lifetime'
+          add_values      "$hdd_lifetime"
 
-                                  # START-UP COUNT
-                                  add_attribute   'Start-up count'
-                                  add_values      "$hdd_startup"
+          # START-UP COUNT
+          add_attribute   'Start-up count'
+          add_values      "$hdd_startup"
 
-                                  # HEALTH STATUS
-                                  add_attribute   'Health Status'
-                                  add_values      "$hdd_health"
-                          fi
-                  fi
+          # HEALTH STATUS
+          add_attribute   'Health Status'
+          add_values      "$hdd_health"
+        fi
+      fi
 
 
-                  flush_values
+      flush_values
 
 
-                  ## PARTITION DATA
-                  add_header	'' # adds a space into stdout, does not affect xml
-                  add_nc_header	" Partition%col%mountpoint%col%blocks%col%free%col%filesystem\n"
-                  add_nc_header	" ---------%col%----------%col%------%col%----%col%----------"
+      ## PARTITION DATA
+      add_header	'' # adds a space into stdout, does not affect xml
+      add_nc_header	" Partition%col%mountpoint%col%blocks%col%free%col%filesystem\n"
+      add_nc_header	" ---------%col%----------%col%------%col%----%col%----------"
 
-                  for hdd_pt in $(seq 1 1 $partitions_on_drive); do
-                          # print the device node
-                          add_attribute "  ${hdd_pt_node[$hdd_pt]}"
+      for hdd_pt in $(seq 1 1 $partitions_on_drive); do
+        # print the device node
+        add_attribute "  ${hdd_pt_node[$hdd_pt]}"
 
-                          # print info of mounted drives
-                          if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists
+        # print info of mounted drives
+        if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists
 
-                                  # mount point
-                                  add_values    "${hdd_pt_mp[$hdd_pt]}"
+          # mount point
+          add_values    "${hdd_pt_mp[$hdd_pt]}"
 
-                                  # blocks
-                                  add_values    "$(hdd_human_readable \
-                                                            ${hdd_pt_blocks[$hdd_pt]})"
-                                  # free
-                                  if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
-                                  add_values    "$(hdd_human_readable \
-                                                            ${hdd_pt_free[$hdd_pt]})"
-                                  #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
-                                  else
-                                          add_values '-'
-                                  fi
+          # blocks
+          add_values    "$(hdd_human_readable \
+                                    ${hdd_pt_blocks[$hdd_pt]})"
+          # free
+          if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
+          add_values    "$(hdd_human_readable \
+                                    ${hdd_pt_free[$hdd_pt]})"
+          #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
+          else
+            add_values '-'
+          fi
 
-                                  # fs type
-                                  add_values    "${hdd_pt_fs[$hdd_pt]}"
+          # fs type
+          add_values    "${hdd_pt_fs[$hdd_pt]}"
 
-                          else
+        else
 
-                                  # mount point
-                                  add_values    " "
+          # mount point
+          add_values    " "
 
-                                  # blocks
-                                  add_values    "$(hdd_human_readable \
-                                                            ${hdd_pt_blocks[$hdd_pt]})"
+          # blocks
+          add_values    "$(hdd_human_readable \
+                                    ${hdd_pt_blocks[$hdd_pt]})"
 
-                                  # free would come here
-                                  add_values    ' '
+          # free would come here
+          add_values    ' '
 
-                                  # fs type
-                                  add_values    "${hdd_pt_fs[$hdd_pt]}"
+          # fs type
+          add_values    "${hdd_pt_fs[$hdd_pt]}"
 
-                          fi
+        fi
 
-                  done
+      done
 
-                  flush_values
-                  ;;
+      flush_values
+      ;;
 
-          'xml')	# XML OUTPUT
+    'xml')	# XML OUTPUT
 
-                  add_header    "drive"
+      add_header    "drive"
 
-                          add_attribute "$hdd_type"			'hard_disk'
-                          # TODO: how to break these into many lines in the code?
-                          add_values    "$hdd_type $hdd_vendor $hdd_model ($hdd_serial) $hdd_capacity_label"
+        add_attribute "$hdd_type"			'hard_disk'
+        # TODO: how to break these into many lines in the code?
+        add_values    "$hdd_type $hdd_vendor $hdd_model ($hdd_serial) $hdd_capacity_label"
 
-                          if [ $lanforce -eq 1 ]; then
-                                  add_attribute "partitions"		'drive'
-                          else
-                                  add_header    "partitions"
-                          fi
+        if [ $lanforce -eq 1 ]; then
+          add_attribute "partitions"		'drive'
+        else
+          add_header    "partitions"
+        fi
 
-                          for hdd_pt in $(seq 1 1 $partitions_on_drive); do
-                                  add_values    "${hdd_pt_node[$hdd_pt]} ${hdd_pt_mp[$hdd_pt]} ${hdd_pt_free[$hdd_pt]}/${hdd_pt_blocks[$hdd_pt]} ${hdd_pt_fs[$hdd_pt]}"
-                          done
+        for hdd_pt in $(seq 1 1 $partitions_on_drive); do
+          add_values    "${hdd_pt_node[$hdd_pt]} ${hdd_pt_mp[$hdd_pt]} ${hdd_pt_free[$hdd_pt]}/${hdd_pt_blocks[$hdd_pt]} ${hdd_pt_fs[$hdd_pt]}"
+        done
 
 
-                          if [ $lanforce -eq 0 ]; then
-                                  add_footer
-                          fi
+        if [ $lanforce -eq 0 ]; then
+          add_footer
+        fi
 
-                  add_footer
+      add_footer
 
-                  ;;
+      ;;
   esac
 }
 



From lamikae at mail.berlios.de  Fri Aug 29 17:42:38 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Fri, 29 Aug 2008 17:42:38 +0200
Subject: [Osinfo-commit] r723 - trunk/osinfo/modules
Message-ID: <200808291542.m7TFgcX1005228@sheep.berlios.de>

Author: lamikae
Date: 2008-08-29 17:42:35 +0200 (Fri, 29 Aug 2008)
New Revision: 723

Modified:
   trunk/osinfo/modules/hdd
Log:
added volume label detection (for ext partitions through tune2fs)

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-29 15:30:51 UTC (rev 722)
+++ trunk/osinfo/modules/hdd	2008-08-29 15:42:35 UTC (rev 723)
@@ -9,7 +9,7 @@
 # due to support in recent smartmontools (version 5.36).
 #
 # used tools:
-# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc
+# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc, tune2fs
 Module_hdd() {
   local moduleName="Hard drive configuration"
   local moduleDescription="Information of the hard drives in the system"
@@ -288,13 +288,21 @@
 
       ## PARTITION DATA
       add_header	'' # adds a space into stdout, does not affect xml
-      add_nc_header	" Partition%col%mountpoint%col%blocks%col%free%col%filesystem\n"
-      add_nc_header	" ---------%col%----------%col%------%col%----%col%----------"
+      add_nc_header \
+        " Partition%col%label%col%mountpoint%col%blocks%col%free%col%filesystem\n"
+      add_nc_header \
+        " ---------%col%-----%col%----------%col%------%col%----%col%----------"
 
       for hdd_pt in $(seq 1 1 $partitions_on_drive); do
         # print the device node
         add_attribute "  ${hdd_pt_node[$hdd_pt]}"
 
+        # volume label
+        label=$(tune2fs -l ${hdd_pt_node[$hdd_pt]} 2>/dev/null | \
+          awk -F': ' /volume\ name/{'print $2'})
+        [[ $label == '' ]] && label='n/a'
+        add_values "$label"
+
         # print info of mounted drives
         if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists
 
@@ -302,12 +310,10 @@
           add_values    "${hdd_pt_mp[$hdd_pt]}"
 
           # blocks
-          add_values    "$(hdd_human_readable \
-                                    ${hdd_pt_blocks[$hdd_pt]})"
+          add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
           # free
           if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
-          add_values    "$(hdd_human_readable \
-                                    ${hdd_pt_free[$hdd_pt]})"
+          add_values    "$(hdd_human_readable ${hdd_pt_free[$hdd_pt]})"
           #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
           else
             add_values '-'
@@ -322,8 +328,7 @@
           add_values    " "
 
           # blocks
-          add_values    "$(hdd_human_readable \
-                                    ${hdd_pt_blocks[$hdd_pt]})"
+          add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
 
           # free would come here
           add_values    ' '



From lamikae at mail.berlios.de  Fri Aug 29 18:01:24 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Fri, 29 Aug 2008 18:01:24 +0200
Subject: [Osinfo-commit] r724 - trunk/osinfo/modules
Message-ID: <200808291601.m7TG1Oq2006798@sheep.berlios.de>

Author: lamikae
Date: 2008-08-29 18:01:24 +0200 (Fri, 29 Aug 2008)
New Revision: 724

Modified:
   trunk/osinfo/modules/hdd
Log:
display a message if the partition table is empty

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-29 15:42:35 UTC (rev 723)
+++ trunk/osinfo/modules/hdd	2008-08-29 16:01:24 UTC (rev 724)
@@ -287,60 +287,63 @@
 
 
       ## PARTITION DATA
-      add_header	'' # adds a space into stdout, does not affect xml
-      add_nc_header \
-        " Partition%col%label%col%mountpoint%col%blocks%col%free%col%filesystem\n"
-      add_nc_header \
-        " ---------%col%-----%col%----------%col%------%col%----%col%----------"
+      if [ $partitions_on_drive -le 0 ]; then
+        add_attribute '-- The partition table is empty --'
+      else
+        add_header	'' # adds a space into stdout, does not affect xml
+        add_nc_header \
+          " Partition%col%label%col%mountpoint%col%blocks%col%free%col%filesystem\n"
+        add_nc_header \
+          " ---------%col%-----%col%----------%col%------%col%----%col%----------"
+  
+        for hdd_pt in $(seq 1 1 $partitions_on_drive); do
+          # print the device node
+          add_attribute "  ${hdd_pt_node[$hdd_pt]}"
+  
+          # volume label
+          label=$(tune2fs -l ${hdd_pt_node[$hdd_pt]} 2>/dev/null | \
+            awk -F': ' /volume\ name/{'print $2'})
+          [[ $label == '' ]] && label='n/a'
+          add_values "$label"
+  
+          # print info of mounted drives
+          if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists
+  
+            # mount point
+            add_values    "${hdd_pt_mp[$hdd_pt]}"
+  
+            # blocks
+            add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
+            # free
+            if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
+            add_values    "$(hdd_human_readable ${hdd_pt_free[$hdd_pt]})"
+            #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
+            else
+              add_values '-'
+            fi
 
-      for hdd_pt in $(seq 1 1 $partitions_on_drive); do
-        # print the device node
-        add_attribute "  ${hdd_pt_node[$hdd_pt]}"
+            # fs type
+            add_values    "${hdd_pt_fs[$hdd_pt]}"
 
-        # volume label
-        label=$(tune2fs -l ${hdd_pt_node[$hdd_pt]} 2>/dev/null | \
-          awk -F': ' /volume\ name/{'print $2'})
-        [[ $label == '' ]] && label='n/a'
-        add_values "$label"
-
-        # print info of mounted drives
-        if [ "${hdd_pt_mp[$hdd_pt]}" ]; then #mount point exists
-
-          # mount point
-          add_values    "${hdd_pt_mp[$hdd_pt]}"
-
-          # blocks
-          add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
-          # free
-          if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
-          add_values    "$(hdd_human_readable ${hdd_pt_free[$hdd_pt]})"
-          #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
           else
-            add_values '-'
-          fi
 
-          # fs type
-          add_values    "${hdd_pt_fs[$hdd_pt]}"
+            # mount point
+            add_values    " "
 
-        else
+            # blocks
+            add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
 
-          # mount point
-          add_values    " "
+            # free would come here
+            add_values    ' '
 
-          # blocks
-          add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
+            # fs type
+            add_values    "${hdd_pt_fs[$hdd_pt]}"
 
-          # free would come here
-          add_values    ' '
+          fi
+        done
 
-          # fs type
-          add_values    "${hdd_pt_fs[$hdd_pt]}"
-
-        fi
-
-      done
-
-      flush_values
+        flush_values
+      fi
       ;;
 
     'xml')	# XML OUTPUT



From lamikae at mail.berlios.de  Sun Aug 31 14:30:54 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Sun, 31 Aug 2008 14:30:54 +0200
Subject: [Osinfo-commit] r725 - trunk/osinfo/modules
Message-ID: <200808311230.m7VCUsQs026781@sheep.berlios.de>

Author: lamikae
Date: 2008-08-31 14:30:54 +0200 (Sun, 31 Aug 2008)
New Revision: 725

Modified:
   trunk/osinfo/modules/hdd
Log:
fixed filesystem detection, columnation and unused columns if SMART is not available

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-29 16:01:24 UTC (rev 724)
+++ trunk/osinfo/modules/hdd	2008-08-31 12:30:54 UTC (rev 725)
@@ -9,7 +9,7 @@
 # due to support in recent smartmontools (version 5.36).
 #
 # used tools:
-# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc, tune2fs
+# fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc, tune2fs, file
 Module_hdd() {
   local moduleName="Hard drive configuration"
   local moduleDescription="Information of the hard drives in the system"
@@ -252,13 +252,14 @@
       # SMART capability; more verbose
       if [ $isverbose -ge 2 ]; then
         # SMART capability
+        [[ "$hdd_smart" == "" ]] && hdd_smart="Device does not support SMART"
         add_attribute   'S.M.A.R.T.'
         add_values      "$hdd_smart"
       fi
 
       # S.M.A.R.T DATA
       # TODO: use add_subheader
-      if [ "$(type -p smartctl)" ]; then
+      if [ "$(type -p smartctl)" ] && [ "$hdd_smart" ]; then
 
         # TEMPERATURE
         add_attribute   'Temperature'
@@ -314,16 +315,15 @@
   
             # blocks
             add_values    "$(hdd_human_readable ${hdd_pt_blocks[$hdd_pt]})"
+
             # free
-            if [ "${hdd_pt_free[$hdd_pt]}" != "" ]; then
             add_values    "$(hdd_human_readable ${hdd_pt_free[$hdd_pt]})"
-            #add_values    "${hdd_pt_free_pc[$hdd_pt]})"
-            else
-              add_values '-'
-            fi
 
-            # fs type
-            add_values    "${hdd_pt_fs[$hdd_pt]}"
+            # filesystem
+            fs="$(file -sL ${hdd_pt_node[$hdd_pt]} 2>/dev/null | awk -F': |\(' {'print $2'})"
+            [[ "$(grep ^ERROR <<< $fs)" ]] && \
+              fs="${hdd_pt_fs[$hdd_pt]}" # detection failed, use fdisk's value
+            add_values "$fs"
 
           else
 
@@ -698,6 +698,8 @@
                 fi
 
                 echo "${hdd_val}"
+        else
+          echo "n/a"
         fi
 }
 



From lamikae at mail.berlios.de  Sun Aug 31 14:33:09 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Sun, 31 Aug 2008 14:33:09 +0200
Subject: [Osinfo-commit] r726 - trunk/osinfo/modules
Message-ID: <200808311233.m7VCX9IZ026874@sheep.berlios.de>

Author: lamikae
Date: 2008-08-31 14:33:09 +0200 (Sun, 31 Aug 2008)
New Revision: 726

Modified:
   trunk/osinfo/modules/hdd
Log:
fixed some indentation

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-31 12:30:54 UTC (rev 725)
+++ trunk/osinfo/modules/hdd	2008-08-31 12:33:09 UTC (rev 726)
@@ -296,11 +296,11 @@
           " Partition%col%label%col%mountpoint%col%blocks%col%free%col%filesystem\n"
         add_nc_header \
           " ---------%col%-----%col%----------%col%------%col%----%col%----------"
-  
+
         for hdd_pt in $(seq 1 1 $partitions_on_drive); do
           # print the device node
           add_attribute "  ${hdd_pt_node[$hdd_pt]}"
-  
+
           # volume label
           label=$(tune2fs -l ${hdd_pt_node[$hdd_pt]} 2>/dev/null | \
             awk -F': ' /volume\ name/{'print $2'})
@@ -490,40 +490,40 @@
 #  (2) device type (man smartctl for details)
 #
 scan_hdd_smart() {
-        local dev_scan="${1}" dev_type smart_info version
-        if [ "$2" ]; then
-                dev_type="$2"
-        else
-                dev_type=ata
-        fi
+  local dev_scan="${1}" dev_type smart_info version
+  if [ "$2" ]; then
+    dev_type="$2"
+  else
+    dev_type=ata
+  fi
 
-        CheckReq_smartctl # allocates temp file $smart_info
-        # allocate a temp file
-        smart_info="$(mktemp /tmp/osinfo.XXXXXX)"
-        TempFiles=("${TempFiles[@]}" "$smart_info")
+  CheckReq_smartctl # allocates temp file $smart_info
+  # allocate a temp file
+  smart_info="$(mktemp /tmp/osinfo.XXXXXX)"
+  TempFiles=("${TempFiles[@]}" "$smart_info")
 
-        smartctl -a -d $dev_type ${dev_scan}  2> ${error_log} > $smart_info
+  smartctl -a -d $dev_type ${dev_scan}  2> ${error_log} > $smart_info
 
-        hdd_smart="$(grep 'SMART support' ${smart_info} | \
-                    head -n 1 | awk -F': ' {'print $2'})"
+  hdd_smart="$(grep 'SMART support' ${smart_info} | \
+    head -n 1 | awk -F': ' {'print $2'})"
 
-        hdd_lifetime="$(grep -i power_on $smart_info | awk {'print $NF'})"
+  hdd_lifetime="$(grep -i power_on $smart_info | awk {'print $NF'})"
 
-        hdd_startup="$(grep -i start_stop $smart_info | awk {'print $NF'})"
+  hdd_startup="$(grep -i start_stop $smart_info | awk {'print $NF'})"
 
-        # prefer hddtemp
-        if [ "$(type -p hddtemp)" ]; then
-                hdd_tempC="$(hddtemp $dev_scan | awk -F: {'print $NF'})"
-        else
-                hdd_tempC="$(grep -i temperature_celsius $smart_info | \
-                    awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"
-        fi
+  # prefer hddtemp
+  if [ "$(type -p hddtemp)" ]; then
+    hdd_tempC="$(hddtemp $dev_scan | awk -F: {'print $NF'})"
+  else
+    hdd_tempC="$(grep -i temperature_celsius $smart_info | \
+      awk '{for (i=10; i<=NF; i++) printf("%s ",$i);printf ("\n")}')"
+  fi
 
-        hdd_health="$( grep -Ei '(health)+' $smart_info | awk {'print $NF'})"
+  hdd_health="$(grep -Ei '(health)+' $smart_info | awk {'print $NF'})"
 
-        # ATA Standard
-        hdd_ata_standard="$(grep -i '^ATA Standard' ${smart_info} | \
-                            awk -F: {'print $2'} | sed 's/^ *//') "
+  # ATA Standard
+  hdd_ata_standard="$(grep -i '^ATA Standard' ${smart_info} | \
+    awk -F: {'print $2'} | sed 's/^ *//') "
 }
 
 
@@ -655,52 +655,52 @@
 #  (2) significant digits _after_ decimal, default 1
 #
 hdd_human_readable() {
-        local value="${1}"
+  local value="${1}"
 
-        # check if the input if proper
-        if [ "$(grep [0-9] <<< $value)" ]; then
+  # check if the input if proper
+  if [ "$(grep [0-9] <<< $value)" ]; then
 
-                if [ ! "$2" ]; then
-                        local digits=1
-                else
-                        local digits="${2}"
-                fi
+    if [ ! "$2" ]; then
+      local digits=1
+    else
+      local digits="${2}"
+    fi
 
-                # dimension, 10^3 multiple of bytes, e.g. 'GB', defaults to MB
-                case $(bc -s <<< ${value}/1024 | wc -m ) in
-                        '1'|'2'|'3'|'4')
-                                local dim='MB'
-                                local denominator="1024"
-                                ;;
-                        '5'|'6'|'7')
-                                local dim='GB'
-                                local denominator='1024^2'
-                                ;;
-                        '8'|'9'|'10')
-                                local dim='TB'
-                                local denominator="1024^3"
-                                ;;
-                        '11'|'12'|'13')
-                                local dim='PB'
-                                local denominator="1024^4"
-                                ;;
-                        *)
-                                local dim='kB'
-                                local denominator="1"
-                                ;;
-                esac
+    # dimension, 10^3 multiple of bytes, e.g. 'GB', defaults to MB
+    case $(bc -s <<< ${value}/1024 | wc -m ) in
+      '1'|'2'|'3'|'4')
+        local dim='MB'
+        local denominator="1024"
+        ;;
+      '5'|'6'|'7')
+        local dim='GB'
+        local denominator='1024^2'
+        ;;
+      '8'|'9'|'10')
+        local dim='TB'
+        local denominator="1024^3"
+        ;;
+      '11'|'12'|'13')
+        local dim='PB'
+        local denominator="1024^4"
+        ;;
+      *)
+        local dim='kB'
+        local denominator="1"
+        ;;
+    esac
 
-                local hdd_val="$(bc -s <<< scale=$digits\;${value}/${denominator}) $dim"
+    local hdd_val="$(bc -s <<< scale=$digits\;${value}/${denominator}) $dim"
 
-                # check if val<1
-                if [ "${hdd_val:0:1}" == "." ]; then
-                        hdd_val="0${hdd_val}"
-                fi
+    # check if val<1
+    if [ "${hdd_val:0:1}" == "." ]; then
+      hdd_val="0${hdd_val}"
+    fi
 
-                echo "${hdd_val}"
-        else
-          echo "n/a"
-        fi
+    echo "${hdd_val}"
+  else
+    echo "n/a"
+  fi
 }
 
 



From lamikae at mail.berlios.de  Sun Aug 31 14:51:48 2008
From: lamikae at mail.berlios.de (lamikae at BerliOS)
Date: Sun, 31 Aug 2008 14:51:48 +0200
Subject: [Osinfo-commit] r727 - trunk/osinfo/modules
Message-ID: <200808311251.m7VCpmNv029725@sheep.berlios.de>

Author: lamikae
Date: 2008-08-31 14:51:48 +0200 (Sun, 31 Aug 2008)
New Revision: 727

Modified:
   trunk/osinfo/modules/hdd
Log:
smarter SMART detection

Modified: trunk/osinfo/modules/hdd
===================================================================
--- trunk/osinfo/modules/hdd	2008-08-31 12:33:09 UTC (rev 726)
+++ trunk/osinfo/modules/hdd	2008-08-31 12:51:48 UTC (rev 727)
@@ -11,7 +11,7 @@
 # used tools:
 # fdisk, df, udev, /proc (deprecated), smartmontools, hdparm, bc, tune2fs, file
 Module_hdd() {
-  local moduleName="Hard drive configuration"
+  local moduleName="System hard drives"
   local moduleDescription="Information of the hard drives in the system"
   module_header "${moduleName}"
 
@@ -252,9 +252,12 @@
       # SMART capability; more verbose
       if [ $isverbose -ge 2 ]; then
         # SMART capability
-        [[ "$hdd_smart" == "" ]] && hdd_smart="Device does not support SMART"
         add_attribute   'S.M.A.R.T.'
-        add_values      "$hdd_smart"
+        if [ "$hdd_smart" == "" ]; then
+          add_values "Device does not support SMART"
+        else
+          add_values      "$hdd_smart"
+        fi
       fi
 
       # S.M.A.R.T DATA



